use anyhow::{bail, Result};
use dialoguer::{Confirm, Input, MultiSelect, Password, Select};
use std::collections::HashMap;
use std::path::PathBuf;

use crate::config::types::*;

/// Wizard depth level — each includes all sections from previous levels.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Depth {
    /// Server + Users only
    Quick,
    /// + Security, ACL, API, Metrics, Logging
    Standard,
    /// + Groups, GeoIP, Webhooks, Alerting, Maintenance, Connection Pool, Upstream Proxy
    Advanced,
}

/// Run the interactive wizard and return a fully built AppConfig.
///
/// If `non_interactive` is true, all defaults are used (Quick depth).
pub fn run_wizard(non_interactive: bool) -> Result<AppConfig> {
    if non_interactive {
        return build_non_interactive_config();
    }

    if !is_tty() {
        bail!(
            "stdin is not a terminal. Use --non-interactive for non-TTY environments, \
             or pipe input from a terminal."
        );
    }

    eprintln!();
    eprintln!("  sks5 configuration wizard");
    eprintln!("  =======================");
    eprintln!();

    let depth = prompt_depth()?;

    let mut config = AppConfig {
        server: prompt_server()?,
        shell: ShellConfig::default(),
        limits: LimitsConfig::default(),
        security: SecurityConfig::default(),
        logging: LoggingConfig::default(),
        metrics: MetricsConfig::default(),
        api: ApiConfig::default(),
        geoip: GeoIpConfig::default(),
        upstream_proxy: None,
        webhooks: Vec::new(),
        acl: GlobalAclConfig::default(),
        users: Vec::new(),
        groups: Vec::new(),
        motd: MotdConfig::default(),
        alerting: AlertingConfig::default(),
        maintenance_windows: Vec::new(),
        connection_pool: ConnectionPoolConfig::default(),
    };

    // Users (always)
    prompt_users(&mut config)?;

    if depth == Depth::Standard || depth == Depth::Advanced {
        // Security
        if confirm_section("security settings (autoban, IP guard)")? {
            prompt_security(&mut config)?;
        }

        // ACL
        if confirm_section("global ACL rules")? {
            prompt_acl(&mut config)?;
        }

        // API
        if confirm_section("REST API / dashboard")? {
            prompt_api(&mut config)?;
        }

        // Metrics
        if confirm_section("Prometheus metrics")? {
            prompt_metrics(&mut config)?;
        }

        // Logging
        if confirm_section("logging settings")? {
            prompt_logging(&mut config)?;
        }
    }

    if depth == Depth::Advanced {
        // Groups
        if confirm_section("user groups")? {
            prompt_groups(&mut config)?;
        }

        // GeoIP
        if confirm_section("GeoIP filtering")? {
            prompt_geoip(&mut config)?;
        }

        // Webhooks
        if confirm_section("webhooks")? {
            prompt_webhooks(&mut config)?;
        }

        // Alerting
        if confirm_section("alerting rules")? {
            prompt_alerting(&mut config)?;
        }

        // Maintenance
        if confirm_section("maintenance windows")? {
            prompt_maintenance(&mut config)?;
        }

        // Connection Pool
        if confirm_section("connection pooling")? {
            prompt_connection_pool(&mut config)?;
        }

        // Upstream Proxy
        if confirm_section("upstream SOCKS5 proxy")? {
            prompt_upstream_proxy(&mut config)?;
        }
    }

    Ok(config)
}

/// Serialize the config to TOML with a comment header.
pub fn config_to_toml(config: &AppConfig) -> Result<String> {
    let toml = toml::to_string_pretty(config)?;
    Ok(format!(
        "# sks5 configuration — generated by `sks5 wizard`\n\
         # Documentation: https://github.com/galti3r/sks5\n\
         \n\
         {toml}"
    ))
}

/// Build a non-interactive config with sensible defaults.
fn build_non_interactive_config() -> Result<AppConfig> {
    let password = crate::auth::password::generate_password(20);
    let password_hash = crate::auth::password::hash_password(&password)?;

    eprintln!("Generated credentials (non-interactive mode):");
    eprintln!("  Username: user");
    eprintln!("  Password: {password}");
    eprintln!();

    Ok(AppConfig {
        server: ServerConfig {
            ssh_listen: "0.0.0.0:2222".to_string(),
            socks5_listen: Some("0.0.0.0:1080".to_string()),
            host_key_path: PathBuf::from("host_key"),
            server_id: "SSH-2.0-sks5".to_string(),
            banner: "Welcome to sks5".to_string(),
            motd_path: None,
            proxy_protocol: false,
            allowed_ciphers: Vec::new(),
            allowed_kex: Vec::new(),
            shutdown_timeout: 30,
            socks5_tls_cert: None,
            socks5_tls_key: None,
            dns_cache_ttl: -1,
            dns_cache_max_entries: 1000,
            connect_retry: 0,
            connect_retry_delay_ms: 1000,
            bookmarks_path: None,
            ssh_keepalive_interval_secs: 15,
            ssh_keepalive_max: 3,
            ssh_auth_timeout: 120,
        },
        shell: ShellConfig::default(),
        limits: LimitsConfig::default(),
        security: SecurityConfig::default(),
        logging: LoggingConfig::default(),
        metrics: MetricsConfig::default(),
        api: ApiConfig::default(),
        geoip: GeoIpConfig::default(),
        upstream_proxy: None,
        webhooks: Vec::new(),
        acl: GlobalAclConfig::default(),
        users: vec![default_user("user", password_hash)],
        groups: Vec::new(),
        motd: MotdConfig::default(),
        alerting: AlertingConfig::default(),
        maintenance_windows: Vec::new(),
        connection_pool: ConnectionPoolConfig::default(),
    })
}

fn default_user(username: &str, password_hash: String) -> UserConfig {
    UserConfig {
        username: username.to_string(),
        password_hash: Some(password_hash),
        authorized_keys: Vec::new(),
        allow_forwarding: true,
        allow_shell: Some(true),
        max_new_connections_per_minute: 0,
        max_bandwidth_kbps: 0,
        source_ips: Vec::new(),
        expires_at: None,
        upstream_proxy: None,
        acl: UserAclConfig::default(),
        totp_secret: None,
        totp_enabled: false,
        max_aggregate_bandwidth_kbps: 0,
        group: None,
        role: UserRole::User,
        shell_permissions: None,
        motd: None,
        quotas: None,
        time_access: None,
        auth_methods: None,
        idle_warning_secs: None,
        colors: None,
        connect_retry: None,
        connect_retry_delay_ms: None,
        aliases: HashMap::new(),
        max_connections: None,
        rate_limits: None,
    }
}

fn is_tty() -> bool {
    use std::io::IsTerminal;
    std::io::stdin().is_terminal()
}

fn prompt_depth() -> Result<Depth> {
    let items = &[
        "Quick     — Server + Users (get started fast)",
        "Standard  — + Security, ACL, API, Metrics, Logging",
        "Advanced  — + Groups, GeoIP, Webhooks, Alerting, Maintenance, ...",
    ];

    let selection = Select::new()
        .with_prompt("Configuration depth")
        .items(items)
        .default(0)
        .interact()?;

    Ok(match selection {
        0 => Depth::Quick,
        1 => Depth::Standard,
        _ => Depth::Advanced,
    })
}

fn confirm_section(name: &str) -> Result<bool> {
    Ok(Confirm::new()
        .with_prompt(format!("Configure {name}?"))
        .default(true)
        .interact()?)
}

// ---------------------------------------------------------------------------
// Section: Server
// ---------------------------------------------------------------------------
fn prompt_server() -> Result<ServerConfig> {
    let ssh_listen: String = Input::new()
        .with_prompt("SSH listen address")
        .default("0.0.0.0:2222".to_string())
        .interact_text()?;

    let enable_socks5 = Confirm::new()
        .with_prompt("Enable standalone SOCKS5 listener?")
        .default(true)
        .interact()?;

    let socks5_listen = if enable_socks5 {
        let addr: String = Input::new()
            .with_prompt("SOCKS5 listen address")
            .default("0.0.0.0:1080".to_string())
            .interact_text()?;
        Some(addr)
    } else {
        None
    };

    let banner: String = Input::new()
        .with_prompt("SSH banner message")
        .default("Welcome to sks5".to_string())
        .interact_text()?;

    Ok(ServerConfig {
        ssh_listen,
        socks5_listen,
        host_key_path: PathBuf::from("host_key"),
        server_id: "SSH-2.0-sks5".to_string(),
        banner,
        motd_path: None,
        proxy_protocol: false,
        allowed_ciphers: Vec::new(),
        allowed_kex: Vec::new(),
        shutdown_timeout: 30,
        socks5_tls_cert: None,
        socks5_tls_key: None,
        dns_cache_ttl: -1,
        dns_cache_max_entries: 1000,
        connect_retry: 0,
        connect_retry_delay_ms: 1000,
        bookmarks_path: None,
        ssh_keepalive_interval_secs: 15,
        ssh_keepalive_max: 3,
        ssh_auth_timeout: 120,
    })
}

// ---------------------------------------------------------------------------
// Section: Users (loop)
// ---------------------------------------------------------------------------
fn prompt_users(config: &mut AppConfig) -> Result<()> {
    loop {
        eprintln!();
        let username: String = Input::new()
            .with_prompt("Username")
            .default("user".to_string())
            .interact_text()?;

        let auth_items = &["Password", "Public key", "Both"];
        let auth_method = Select::new()
            .with_prompt("Authentication method")
            .items(auth_items)
            .default(0)
            .interact()?;

        let password_hash = if auth_method == 0 || auth_method == 2 {
            let password = Password::new()
                .with_prompt("Password")
                .with_confirmation("Confirm password", "Passwords don't match")
                .interact()?;

            if password.is_empty() {
                bail!("password must not be empty");
            }

            eprintln!("  Hashing password with Argon2id...");
            Some(crate::auth::password::hash_password(&password)?)
        } else {
            None
        };

        let authorized_keys = if auth_method == 1 || auth_method == 2 {
            let keys: String = Input::new()
                .with_prompt("Public key(s) (one per line, empty to skip)")
                .default(String::new())
                .allow_empty(true)
                .interact_text()?;
            keys.lines()
                .map(|l| l.trim().to_string())
                .filter(|l| !l.is_empty())
                .collect()
        } else {
            Vec::new()
        };

        let allow_shell = Confirm::new()
            .with_prompt("Allow shell access?")
            .default(true)
            .interact()?;

        config.users.push(UserConfig {
            username,
            password_hash,
            authorized_keys,
            allow_forwarding: true,
            allow_shell: Some(allow_shell),
            max_new_connections_per_minute: 0,
            max_bandwidth_kbps: 0,
            source_ips: Vec::new(),
            expires_at: None,
            upstream_proxy: None,
            acl: UserAclConfig::default(),
            totp_secret: None,
            totp_enabled: false,
            max_aggregate_bandwidth_kbps: 0,
            group: None,
            role: UserRole::User,
            shell_permissions: None,
            motd: None,
            quotas: None,
            time_access: None,
            auth_methods: None,
            idle_warning_secs: None,
            colors: None,
            connect_retry: None,
            connect_retry_delay_ms: None,
            aliases: HashMap::new(),
            max_connections: None,
            rate_limits: None,
        });

        let add_another = Confirm::new()
            .with_prompt("Add another user?")
            .default(false)
            .interact()?;

        if !add_another {
            break;
        }
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Security
// ---------------------------------------------------------------------------
fn prompt_security(config: &mut AppConfig) -> Result<()> {
    let ban_enabled = Confirm::new()
        .with_prompt("Enable autoban (block IPs after failed auth attempts)?")
        .default(true)
        .interact()?;

    config.security.ban_enabled = ban_enabled;

    if ban_enabled {
        config.security.ban_threshold = Input::new()
            .with_prompt("Ban threshold (failed attempts)")
            .default(5u32)
            .interact_text()?;

        config.security.ban_window = Input::new()
            .with_prompt("Ban window (seconds)")
            .default(300u64)
            .interact_text()?;

        config.security.ban_duration = Input::new()
            .with_prompt("Ban duration (seconds)")
            .default(900u64)
            .interact_text()?;
    }

    config.security.ip_guard_enabled = Confirm::new()
        .with_prompt("Enable IP guard (block connections to private/internal IPs)?")
        .default(true)
        .interact()?;

    let source_ips: String = Input::new()
        .with_prompt("Allowed source IPs (comma-separated CIDRs, empty for all)")
        .default(String::new())
        .allow_empty(true)
        .interact_text()?;

    if !source_ips.is_empty() {
        config.security.allowed_source_ips = source_ips
            .split(',')
            .map(|s| {
                s.trim()
                    .parse()
                    .map_err(|e| anyhow::anyhow!("invalid CIDR '{}': {}", s.trim(), e))
            })
            .collect::<Result<Vec<_>>>()?;
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: ACL
// ---------------------------------------------------------------------------
fn prompt_acl(config: &mut AppConfig) -> Result<()> {
    let policies = &[
        "allow (default — permit all, block specific)",
        "deny (block all, permit specific)",
    ];
    let policy = Select::new()
        .with_prompt("Default ACL policy")
        .items(policies)
        .default(0)
        .interact()?;

    config.acl.default_policy = if policy == 0 {
        AclPolicyConfig::Allow
    } else {
        AclPolicyConfig::Deny
    };

    let deny: String = Input::new()
        .with_prompt("Deny rules (comma-separated, e.g. '169.254.169.254:*,10.0.0.0/8:*')")
        .default("169.254.169.254:*".to_string())
        .allow_empty(true)
        .interact_text()?;

    config.acl.deny = deny
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    if config.acl.default_policy == AclPolicyConfig::Deny {
        let allow: String = Input::new()
            .with_prompt("Allow rules (comma-separated, e.g. '*:443,*:80')")
            .default(String::new())
            .allow_empty(true)
            .interact_text()?;

        config.acl.allow = allow
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: API
// ---------------------------------------------------------------------------
fn prompt_api(config: &mut AppConfig) -> Result<()> {
    config.api.enabled = true;

    config.api.listen = Input::new()
        .with_prompt("API listen address")
        .default("127.0.0.1:9091".to_string())
        .interact_text()?;

    let token: String = Input::new()
        .with_prompt("API token (empty to auto-generate)")
        .default(String::new())
        .allow_empty(true)
        .interact_text()?;

    config.api.token = if token.is_empty() {
        let generated = crate::auth::password::generate_password(32);
        eprintln!("  Generated API token: {generated}");
        generated
    } else {
        token
    };

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Metrics
// ---------------------------------------------------------------------------
fn prompt_metrics(config: &mut AppConfig) -> Result<()> {
    config.metrics.enabled = true;

    config.metrics.listen = Input::new()
        .with_prompt("Metrics listen address")
        .default("127.0.0.1:9090".to_string())
        .interact_text()?;

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Logging
// ---------------------------------------------------------------------------
fn prompt_logging(config: &mut AppConfig) -> Result<()> {
    let levels = &["trace", "debug", "info", "warn", "error"];
    let level = Select::new()
        .with_prompt("Log level")
        .items(levels)
        .default(2) // info
        .interact()?;

    config.logging.level = match level {
        0 => LogLevel::Trace,
        1 => LogLevel::Debug,
        2 => LogLevel::Info,
        3 => LogLevel::Warn,
        _ => LogLevel::Error,
    };

    let formats = &["pretty", "json"];
    let format = Select::new()
        .with_prompt("Log format")
        .items(formats)
        .default(0)
        .interact()?;

    config.logging.format = if format == 0 {
        LogFormat::Pretty
    } else {
        LogFormat::Json
    };

    let audit = Confirm::new()
        .with_prompt("Enable audit log?")
        .default(false)
        .interact()?;

    if audit {
        let path: String = Input::new()
            .with_prompt("Audit log path")
            .default("audit.log".to_string())
            .interact_text()?;
        config.logging.audit_log_path = Some(PathBuf::from(path));
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Groups (Advanced)
// ---------------------------------------------------------------------------
fn prompt_groups(config: &mut AppConfig) -> Result<()> {
    loop {
        let name: String = Input::new().with_prompt("Group name").interact_text()?;

        let max_bw: u64 = Input::new()
            .with_prompt("Max bandwidth per user (kbps, 0=unlimited)")
            .default(0u64)
            .interact_text()?;

        let max_conn: u32 = Input::new()
            .with_prompt("Max connections per user (0=unlimited)")
            .default(0u32)
            .interact_text()?;

        config.groups.push(GroupConfig {
            name,
            acl: UserAclConfig::default(),
            max_connections_per_user: if max_conn > 0 { Some(max_conn) } else { None },
            max_bandwidth_kbps: if max_bw > 0 { Some(max_bw) } else { None },
            max_aggregate_bandwidth_kbps: None,
            max_new_connections_per_minute: None,
            allow_forwarding: None,
            allow_shell: None,
            shell_permissions: None,
            motd: None,
            quotas: None,
            time_access: None,
            auth_methods: None,
            idle_warning_secs: None,
            role: None,
            colors: None,
            connect_retry: None,
            connect_retry_delay_ms: None,
            rate_limits: None,
        });

        if !Confirm::new()
            .with_prompt("Add another group?")
            .default(false)
            .interact()?
        {
            break;
        }
    }

    // Assign users to groups
    if !config.groups.is_empty() && !config.users.is_empty() {
        let group_names: Vec<&str> = config.groups.iter().map(|g| g.name.as_str()).collect();
        let user_names: Vec<String> = config.users.iter().map(|u| u.username.clone()).collect();

        for user_name in &user_names {
            let items: Vec<String> = std::iter::once("(none)".to_string())
                .chain(group_names.iter().map(|g| g.to_string()))
                .collect();

            let selection = Select::new()
                .with_prompt(format!("Group for user '{user_name}'"))
                .items(&items)
                .default(0)
                .interact()?;

            if selection > 0 {
                if let Some(user) = config.users.iter_mut().find(|u| u.username == *user_name) {
                    user.group = Some(group_names[selection - 1].to_string());
                }
            }
        }
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: GeoIP (Advanced)
// ---------------------------------------------------------------------------
fn prompt_geoip(config: &mut AppConfig) -> Result<()> {
    config.geoip.enabled = true;

    let db_path: String = Input::new()
        .with_prompt("GeoIP database path (MaxMind .mmdb)")
        .default("GeoLite2-Country.mmdb".to_string())
        .interact_text()?;
    config.geoip.database_path = Some(PathBuf::from(db_path));

    let allowed: String = Input::new()
        .with_prompt("Allowed countries (comma-separated ISO codes, empty=all)")
        .default(String::new())
        .allow_empty(true)
        .interact_text()?;

    config.geoip.allowed_countries = allowed
        .split(',')
        .map(|s| s.trim().to_uppercase())
        .filter(|s| !s.is_empty())
        .collect();

    let denied: String = Input::new()
        .with_prompt("Denied countries (comma-separated ISO codes)")
        .default(String::new())
        .allow_empty(true)
        .interact_text()?;

    config.geoip.denied_countries = denied
        .split(',')
        .map(|s| s.trim().to_uppercase())
        .filter(|s| !s.is_empty())
        .collect();

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Webhooks (Advanced)
// ---------------------------------------------------------------------------
fn prompt_webhooks(config: &mut AppConfig) -> Result<()> {
    loop {
        let url: String = Input::new().with_prompt("Webhook URL").interact_text()?;

        let available_events = &[
            "connection.opened",
            "connection.closed",
            "auth.success",
            "auth.failure",
            "ban.added",
            "ban.removed",
        ];

        let selected = MultiSelect::new()
            .with_prompt("Events to subscribe (space to select)")
            .items(available_events)
            .interact()?;

        let events: Vec<String> = selected
            .iter()
            .map(|&i| available_events[i].to_string())
            .collect();

        let secret: String = Input::new()
            .with_prompt("HMAC secret (empty to skip)")
            .default(String::new())
            .allow_empty(true)
            .interact_text()?;

        config.webhooks.push(WebhookConfig {
            url,
            events,
            secret: if secret.is_empty() {
                None
            } else {
                Some(secret)
            },
            allow_private_ips: false,
            max_retries: 3,
            retry_delay_ms: 1000,
            max_retry_delay_ms: 30000,
        });

        if !Confirm::new()
            .with_prompt("Add another webhook?")
            .default(false)
            .interact()?
        {
            break;
        }
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Alerting (Advanced)
// ---------------------------------------------------------------------------
fn prompt_alerting(config: &mut AppConfig) -> Result<()> {
    config.alerting.enabled = true;

    loop {
        let name: String = Input::new()
            .with_prompt("Alert rule name")
            .interact_text()?;

        let conditions = &[
            "bandwidth_exceeded",
            "connections_exceeded",
            "monthly_bandwidth_exceeded",
            "hourly_bandwidth_exceeded",
            "auth_failures",
        ];

        let cond_idx = Select::new()
            .with_prompt("Condition")
            .items(conditions)
            .default(0)
            .interact()?;

        let condition = match cond_idx {
            0 => AlertCondition::BandwidthExceeded,
            1 => AlertCondition::ConnectionsExceeded,
            2 => AlertCondition::MonthlyBandwidthExceeded,
            3 => AlertCondition::HourlyBandwidthExceeded,
            _ => AlertCondition::AuthFailures,
        };

        let threshold: u64 = Input::new()
            .with_prompt("Threshold value")
            .default(100u64)
            .interact_text()?;

        let webhook_url: String = Input::new()
            .with_prompt("Webhook URL for alert (empty to skip)")
            .default(String::new())
            .allow_empty(true)
            .interact_text()?;

        config.alerting.rules.push(AlertRule {
            name,
            condition,
            threshold,
            window_secs: 3600,
            users: Vec::new(),
            webhook_url: if webhook_url.is_empty() {
                None
            } else {
                Some(webhook_url)
            },
        });

        if !Confirm::new()
            .with_prompt("Add another alert rule?")
            .default(false)
            .interact()?
        {
            break;
        }
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Maintenance (Advanced)
// ---------------------------------------------------------------------------
fn prompt_maintenance(config: &mut AppConfig) -> Result<()> {
    loop {
        let schedule: String = Input::new()
            .with_prompt("Schedule (e.g. 'daily 03:00-04:00' or 'Sun 02:00-04:00')")
            .interact_text()?;

        let message: String = Input::new()
            .with_prompt("Maintenance message")
            .default("Server is under scheduled maintenance. Please try again later.".to_string())
            .interact_text()?;

        let disconnect = Confirm::new()
            .with_prompt("Disconnect existing sessions?")
            .default(false)
            .interact()?;

        config.maintenance_windows.push(MaintenanceWindowConfig {
            schedule,
            timezone: "UTC".to_string(),
            message,
            disconnect_existing: disconnect,
        });

        if !Confirm::new()
            .with_prompt("Add another maintenance window?")
            .default(false)
            .interact()?
        {
            break;
        }
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Connection Pool (Advanced)
// ---------------------------------------------------------------------------
fn prompt_connection_pool(config: &mut AppConfig) -> Result<()> {
    config.connection_pool.enabled = true;

    config.connection_pool.max_idle_per_host = Input::new()
        .with_prompt("Max idle connections per host")
        .default(10u32)
        .interact_text()?;

    config.connection_pool.idle_timeout_secs = Input::new()
        .with_prompt("Idle timeout (seconds)")
        .default(60u64)
        .interact_text()?;

    Ok(())
}

// ---------------------------------------------------------------------------
// Section: Upstream Proxy (Advanced)
// ---------------------------------------------------------------------------
fn prompt_upstream_proxy(config: &mut AppConfig) -> Result<()> {
    let url: String = Input::new()
        .with_prompt("Upstream SOCKS5 proxy URL (e.g. socks5://host:port)")
        .interact_text()?;

    config.upstream_proxy = Some(UpstreamProxyConfig { url });

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config;

    #[test]
    fn test_non_interactive_produces_valid_config() {
        let config = build_non_interactive_config().expect("non-interactive config should build");
        assert_eq!(config.server.ssh_listen, "0.0.0.0:2222");
        assert_eq!(config.users.len(), 1);
        assert_eq!(config.users[0].username, "user");
        assert!(config.users[0].password_hash.is_some());

        // Validate through the config validator
        config::parse_config_validate(&config).expect("config should validate");
    }

    #[test]
    fn test_non_interactive_config_serializes_to_valid_toml() {
        let config = build_non_interactive_config().expect("non-interactive config should build");
        let toml_str = config_to_toml(&config).expect("should serialize to TOML");

        // Must contain key sections
        assert!(toml_str.contains("[server]"));
        assert!(toml_str.contains("[[users]]"));
        assert!(toml_str.contains("ssh_listen"));

        // Must round-trip through TOML parser
        let reparsed: AppConfig = toml::from_str(&toml_str).expect("generated TOML should reparse");
        assert_eq!(reparsed.server.ssh_listen, "0.0.0.0:2222");
        assert_eq!(reparsed.users.len(), 1);
    }

    #[test]
    fn test_default_user_has_correct_defaults() {
        let user = default_user("alice", "hash123".to_string());
        assert_eq!(user.username, "alice");
        assert_eq!(user.password_hash, Some("hash123".to_string()));
        assert!(user.allow_forwarding);
        assert_eq!(user.allow_shell, Some(true));
        assert_eq!(user.role, UserRole::User);
        assert!(user.group.is_none());
    }
}
